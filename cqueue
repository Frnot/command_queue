#!/usr/bin/env python3

import sys
import socket
import threading
import pickle
from threading import Thread
from os import system as cmd

version = "2.4.0"
# Process exits cleanly when all queues are empty
# slight regression, moved from multiprocessing.connections to sockets
# possibly dangerous use of sockets
# possibly dangerous use of threads


# global stuff
queue_list = []
exit_event = threading.Event()


def main():
    #sys.argv.extend((1, "echo test1; sleep 10; echo test2"))

    if len(sys.argv) < 3:
        print("usage: cqueue.py <queue num> <command>")
        return

    queue_num = sys.argv[1]
    command = sys.argv[2]

    uds_address = '\0' + 'uds_socket'  # Create UDS file in abstract space

    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
        if bind(sock, uds_address):
            process_input(queue_num, command)

            Thread(target=receive, args=(sock,), daemon=True).start()
            exit_event.wait()
        else:
            send(sock, uds_address, queue_num, command)


def bind(sock, socket_address):
    try:
        sock.bind(socket_address)
        print("Bound socket.")
        return True
    except socket.error:
        print("Socket already exists")
        return False


def send(sock, address, queue_num, command):
    sock.connect(address)
    data = (queue_num, command)
    byte_data = pickle.dumps(data, -1)
    sock.sendall(byte_data)


def receive(sock):
    sock.listen()
    while True:
        conn = sock.accept()[0]
        print('receiving new job')
        byte_data = conn.recv(4096)
        data = pickle.loads(byte_data)
        process_input(data[0], data[1])
        conn.close()


def process_input(queue_num, command):
    # if queue list does not contain a queue with num 'queue_num' make it
    if any(queue.serial() == queue_num for queue in queue_list):
        queue = next((q for q in queue_list if q.serial() == queue_num), None)
        queue.add_job(command)
    else:
        queue = Queue(queue_num, command)
        queue_list.append(queue)


def attempt_exit():
    print("Queue empty, attempting exit.")
    if not any(queue_list):
        print("No jobs queued, exiting.")
        exit_event.set()
    else:
        print("Cannot exit, active queues remaining")


class Queue:
    def run(self):
        while True:
            if any(self.__job_queue):
                command = self.__job_queue.pop(0)
                print(f"Executing command: {command}")
                cmd(command)
            else:
                queue_list.remove(self)
                attempt_exit()
                return

    def __init__(self, serial, command):
        self.__serial = serial
        self.__job_queue = []  # a list of jobs
        self.add_job(command)

        # create and start a thread for this queue object
        Thread(target=self.run).start()

    def add_job(self, command):
        self.__job_queue.append(command)

    # Accessors
    def serial(self):
        return self.__serial


main()
