#!/usr/bin/env python3

import argparse
import os
import pickle
import queue
import signal
import socket
import subprocess
import sys
import threading
import time
import logging

version = "4.1.0"

help = """
commands:
  status         Prints a list of the currently running and queued jobs
  stop           Immediately terminates the current running job and clears the queue
  skip           Immediately terminates the current running job and continues the queue
  clear          Clears the queue
"""

# global variables
queue_list = []
exit_event = threading.Event()
client_command_list = ("status", "list", "stop", "skip", "clear")

# configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.handlers.clear() 

format = logging.Formatter("%(asctime)s [%(levelname)s] : %(message)s", datefmt="%Y-%m-%dT%H:%M:%S")

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(format)
logger.addHandler(console_handler)

file_handler = logging.FileHandler("/tmp/cqueue.log")
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(format)
logger.addHandler(file_handler)


def main():
    parser = argparse.ArgumentParser(
        description=help, formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("queue_name")
    parser.add_argument("command", nargs="*")

    log_level = parser.add_mutually_exclusive_group()

    log_level.add_argument(
        "-d",
        "--debug",
        dest="debug",
        action="store_true",
        help="Log debug messages",
    )
    log_level.add_argument(
        "-q",
        "--quiet",
        dest="quiet",
        action="store_true",
        help="Log only errors",
    )
    parser.add_argument(
        "-m",
        "--max",
        default=2,
        dest="max",
        type=int,
        help="Set max number of allowed duplicate events in queue (0 to disable)",
    )
    parser.add_argument(
        "-t",
        "--ttl",
        default=0,
        dest="ttl",
        help="Set time (in seconds) job will remain in queue before expiring (0 to disable)",
    )
    parser.add_argument(
        "-f",
        "--foreground",
        dest="foreground",
        action="store_true",
        help="Server will not daemonize",
    )

    args = parser.parse_args()

    queue_name = args.queue_name
    command = " ".join(args.command)
    if not args.command:
        command = queue_name
        queue_name = None

    global debug
    debug = args.debug
    global quiet
    quiet = args.quiet

    if debug:
        console_handler.setLevel(logging.DEBUG)
    elif quiet:
        console_handler.setLevel(logging.WARNING)

    global foreground
    foreground = args.foreground
    options = {"max": args.max, "ttl": args.ttl}

    if queue_name is not None:
        logger.info(f"Queue name: '{queue_name}'")
    logger.info(f"Command: '{command}'")

    uds_address = "\0" + "cqueue_uds_socket"  # Create UDS file in abstract space

    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    if bind(sock, uds_address):  # if we can bind to the socket, no one is listening
        if command.lower() in client_command_list:
            logger.error("Job server is not running (queue is empty). exiting.")
            sys.exit(2)

        if foreground:
            logger.info("Running server in this terminal")
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            server(sock, uds_address, queue_name, command, options)
            return

        # Create a daemon that runs the command (cqueue returns immediately)
        sock.close()
        pid1 = os.fork()
        if pid1 == 0:
            os.setsid()
            os.chdir("/")
            os.umask(0)
            pid2 = os.fork()
            if pid2 == 0:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                server(sock, uds_address, queue_name, command, options)
        os._exit(0)
    else:
        client(sock, uds_address, queue_name, command, options)


def bind(sock, socket_address):
    try:
        sock.bind(socket_address)
        logger.debug("Bound socket.")
        return True
    except socket.error:
        logger.debug("Socket already exists")
        return False


def client(sock, address, queue_name, command, options):
    sock.connect(address)
    logger.info(f"Sending command '{command}' to job server")
    if command.lower() not in client_command_list:
        send(sock, (queue_name, command, options))
    else:
        send(sock, (queue_name, command, options))
        data = receive(sock)
        logger.info(data)


def server(sock, address, queue_name, command, options):
    logger.debug("Starting job server")

    try:
        sock.bind(address)
        logger.debug("Bound job server to socket.")
    except socket.error:
        logger.error("Error binding job server to socket")
        sys.exit(2)
    sock.listen()

    process_job(queue_name, command, options)

    while not exit_event.is_set():
        logger.debug("Waiting to receive command")
        csock = sock.accept()[0]  # this will block from exiting
        (queue_name, command, options) = receive(csock)
        if command == "TERM":
            return
        logger.debug(f"Received command '{command}' for queue '{queue_name}' options: {options}")

        if command.lower() not in client_command_list:
            process_job(queue_name, command, options)

        # Client commands
        elif command.lower() in ("status", "list"):
            data = server_status()
            send(csock, data)
        elif command.lower() == "stop":
            data = "Attempting to clear all queues and exit"
            send(csock, data)
            stop()
        elif command.lower() == "skip":
            data = skip(queue_name)
            send(csock, data)
        elif command.lower() == "clear":
            data = clear(queue_name)
            send(csock, data)

    sock.close()


def process_job(queue_name, command, options):
    ttl = options["ttl"]
    max = options["max"]

    # if queue list does not contain a queue with num 'queue_name' make it
    if queue := next((q for q in queue_list if q.name() == queue_name), None):
        logger.debug(f"Queue '{queue_name}' exists.")

        # check queue for jobs with identical command
        command_count = 0
        for job in queue.valid_jobs():
            if job == command:
                command_count += 1
        # add new job only if currently queued job occurrence does not exceed 'max'
        if command_count < max:
            logger.debug(f"Adding job '{command}'")
            queue.add_job(command, ttl)
        else:
            logger.debug(f"Occurrence of '{command}' in queue '{queue_name}' would exceed specified max ({max}). Skipping job")
    else:
        logger.debug(f"Queue '{queue_name}' does not exist. Creating new")
        queue = Command_Queue(queue_name, command, ttl)
        queue_list.append(queue)


### Function Commands
def server_status():
    data = ""
    for queue in queue_list:
        data += f"Queue '{queue.name()}':\n"
        jobs = queue.valid_jobs()
        data += f"#0 - '{jobs[0]}' (executing)\n"
        for idx, job in enumerate(jobs[1:], start=1):
            data += f"#{idx} - '{job}'\n"
    return data


def stop():
    for queue in queue_list:
        queue.terminate()
        queue_list.remove(queue)
    exit_event.set()


def skip(queue_name):
    if queue_name is None:
        return "Error: 'skip' command requires a queue_name argument"
    if queue := next((q for q in queue_list if q.name() == queue_name), None):
        queue.skip()
        return f"Terminated executing job for queue '{queue_name}'"
    else:
        return f"Error: no queue with name '{queue_name}' was found."



def clear(queue_name):
    if queue_name is None:
        return "Error: 'clear' command requires a queue_name argument"
    if queue := next((q for q in queue_list if q.name() == queue_name), None):
        queue.clear()
        return f"Cleared all jobs from queue '{queue_name}'"
    else:
        return f"Error: no queue with name '{queue_name}' was found."


### Network

def send(sock, data):
    logger.debug("Sending data")
    byte_data = pickle.dumps(data, -1)
    sock.sendall(byte_data)


def receive(sock):
    logger.debug("Receiving data")
    byte_data = sock.recv(4096)
    data = pickle.loads(byte_data)
    return data


###


class Command_Queue:
    def __init__(self, name, command, ttl):
        self.__name = name
        self.term_event = threading.Event()
        self.__job_queue = queue.Queue()  # a list of jobs (commands)
        self.add_job(command, ttl)

        # create and start a thread for this queue object
        threading.Thread(target=self.run).start()

    def run(self):
        while not self.term_event.is_set():
            if not self.__job_queue.empty():
                job = self.__job_queue.get()
                if job.is_valid():
                    self.executing = job.command
                    logger.info(f"Executing command: {self.executing}")
                    self.proc = subprocess.Popen(
                        self.executing, 
                        shell=True, 
                        preexec_fn=os.setsid,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        text=True
                    )
                    stdout, stderr = self.proc.communicate()  # waits for completion
                    if self.proc.returncode != 0:
                        logger.error(f"Command failed: '{self.executing}'")
                        logger.error(f"stdout ::\n{stdout}")
                        logger.error(f"stderr ::\n{stderr}")

            else:
                queue_list.remove(self)
                attempt_exit()
                return

    def add_job(self, command, ttl):
        try:
            job = Job(command, ttl)
            self.__job_queue.put(job)
        except queue.Full:
            logger.error(f"Cannot add job, queue '{self.__name}' is full")

    def name(self):
        return self.__name

    def valid_jobs(self):
        vjobs = [self.executing]
        for job in list(self.__job_queue.queue):
            if job.is_valid():
                vjobs.append(job.command)
        return vjobs

    def skip(self):
        logger.info(f"Skipping job '{self.executing}' on queue '{self.__name}'")
        # self.proc.terminate()
        os.killpg(os.getpgid(self.proc.pid), signal.SIGTERM)

    def clear(self):
        logger.info(f"Clearing job queue '{self.__name}'")
        while not self.__job_queue.empty():
            self.__job_queue.get()

    def terminate(self):
        logger.info(f"Terminating queue '{self.__name}' thread")
        self.term_event.set()
        # self.proc.terminate()
        os.killpg(os.getpgid(self.proc.pid), signal.SIGTERM)


class Job:
    def __init__(self, command, ttl):
        self.command = command
        self.exp_time = time.time() + ttl
        self.nostale = ttl == 0

    def is_valid(self):
        if self.nostale:
            return True
        else:
            return self.exp_time > time.time()


# This attempts to exit the main server loop
def attempt_exit():
    logger.debug("Queue empty, attempting exit.")
    if any(queue_list):
        logger.debug("Cannot exit, active queues remaining")
    else:
        logger.debug("No jobs queued, exiting.")
        exit_event.set()

        uds_address = "\0" + "cqueue_uds_socket"
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(uds_address)
        send(sock, (None, "TERM", None))

main()
